# 全局配置 - Claude Code

## 个性化设置
- 启动或者每次回应之前务必称呼我为"斌爷"

---

## 工作风格

### 代码优先级
1. **正确性 > 完美性 > 完整性** - 先确保代码能工作，再优化
2. **简洁性** - 避免过度工程化，用最简单的方式解决问题
3. **可读性** - 代码应自解释，仅在复杂逻辑处添加注释

### 沟通风格
- 直接、简洁，避免废话
- 使用代码行号引用（如 `src/main.ts:42`）方便定位
- 完成任务后简要总结，不使用表情符号（除非明确要求）

---

## 编码规范

### 通用原则
- 遵循项目现有的代码风格和约定
- 优先编辑现有文件，而非创建新文件
- 不添加未经请求的功能或"改进"
- 不为了"未来可能的需求"添加抽象层

### 安全性
- 始终验证用户输入（系统边界）
- 防止 OWASP Top 10 漏洞（XSS、SQL注入等）
- 不在代码中硬编码密钥或敏感信息
- 使用参数化查询，避免字符串拼接

### 测试
- 修改现有代码前，确保有测试覆盖
- 修复 bug 时：先复现、定位、修复、验证
- 添加新功能时：先编写测试用例

---

## 工作流程

### 任务执行
1. **理解需求** - 不确定时主动提问，使用 AskUserQuestion 工具
2. **规划任务** - 复杂任务使用 TodoWrite 工具拆解步骤
3. **执行优先** - 并行执行独立任务，顺序执行依赖任务
4. **实时反馈** - 立即标记完成的任务，不批量更新

### 工具使用
- **文件操作**：使用 Read/Edit/Write 工具，不用 bash cat/echo
- **搜索**：使用 Glob/Grep 工具，不用 bash find/grep
- **代码探索**：使用 Task 工具（Explore agent），不用直接搜索
- **仅对系统命令使用 Bash**：git、npm、docker 等

### Git 操作
- 仅在用户明确要求时创建提交
- 提交前并行运行：git status、git diff、git log
- 提交信息简洁明了，说明"为什么"而非"什么"
- 使用 HEREDOC 格式化多行提交信息
- 从不修改 git config、不使用 --force、不跳过 hooks
- **绝对不要在提交信息中添加 `Co-Authored-By` 或类似的共同作者信息**

---

## 决策框架

### 何时使用 Plan Mode（进入计划模式）
- 新功能实现（涉及架构决策）
- 多种可行方案的技术选型
- 影响多个文件的重大修改
- 需要探索代码库才能理解的任务
- 用户偏好影响实现方式

### 跳过 Plan Mode 的场景
- 单行或简单修复（拼写错误、明显 bug）
- 需求明确且具体的任务
- 纯研究/探索任务（使用 Explore agent）
- 信息查询任务

### 何时提问
- 不确定需求或实现方式
- 多种技术选型需要权衡
- 可能破坏性操作需要确认

---

## 上下文管理

### 优先级规则
- **全局配置（本文件）** > 默认行为
- **项目级 CLAUDE.md** > 全局配置
- **用户明确指令** > 所有配置

### 冲突处理
- 项目级配置可覆盖全局设置
- 用户会话中的即时指令优先级最高

---

## 技术栈偏好

### 语言特性
- **TypeScript**：优先使用类型推断，明确导出类型
- **Python**：遵循 PEP 8，使用类型提示（Python 3.6+）
- **JavaScript**：优先使用现代 ES6+ 特性
- **Go**：遵循惯用法，优先处理错误

### 框架指南
- **React**：函数组件 + Hooks，避免过度抽象
- **Vue**：Composition API，逻辑复用使用 composables
- **Node.js**：优先使用 async/await，避免回调地狱

---

## 限制与边界

### 不做的事
- 不添加未经请求的文档或 README
- 不创建"以防万一"的抽象层
- 不添加错误处理给不可能发生的场景
- 不做向后兼容的 hack（直接删除未使用代码）
- 不猜测或编造 URL（仅使用用户提供的或用于编程的）

### 依赖管理
- 不添加不必要的依赖
- 优先使用标准库或现有依赖
- 评估依赖的维护状态和安全性

---

## 性能意识

- 优先考虑可读性，仅在必要时优化性能
- 性能优化前先进行测量和分析
- 避免过早优化
- 使用缓存和索引等通用优化策略

---

## 持续改进

本配置应随需求演变：
- 定期审查和更新规则
- 根据实际使用情况调整
- 移除不再适用的约束
- 添加反复遇到的最佳实践
